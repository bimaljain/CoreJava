/*
java.util.stream Package 

IntStream
IntStream.Builder
LongStream
LongStream.Builder
DoubleStream
DoubleStream.Builder
Stream
Stream.Builder

Here I am showing method usage for IntStream and IntStream.Builder
Same methods are available for other as well.

 */

package _020_Create_Stream;

import java.util.ArrayList;
import java.util.IntSummaryStatistics;
import java.util.List;
import java.util.OptionalDouble;
import java.util.OptionalInt;
import java.util.PrimitiveIterator;
import java.util.Spliterator;
import java.util.stream.Collectors;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;

import _098_helper.Employee;

public class _011_IntStream_Methods {
	public static void main(String[] args){
		IntStream s1 = IntStream.of(1,2,3,4,5);

		System.out.println("====================CREATE STREAM====================");
		//IntStream of(int t) returns a sequential IntStream containing a single element.
		IntStream s2 = IntStream.of(99);
		s2.forEach(System.out::println);

		//IntStream of(int... values) returns a sequential ordered stream whose elements are the specified values.
		IntStream s5 = IntStream.of(1,2,3,4,5);
		s5.forEach(System.out::println);

		//IntStream builder() returns a builder for an IntStream. build() returns the IntStream.
		s1 = IntStream.builder() 
				.add(1).add(2).add(3).add(4) //add() returns builder
				.build();
		s1.forEach(System.out::println);
		
		IntStream.Builder builder = IntStream.builder();
		builder.accept(1); //accept() returns nothing
		builder.accept(2);
		builder.accept(3);
		builder.accept(4);
		IntStream intStream = builder.build();
		intStream.forEach(System.out::println);

		//IntStream generate(IntSupplier s) returns an infinite sequential unordered stream where each element is generated by the provided IntSupplier
		s1 = IntStream.generate(()->(int)Math.random());
		s1.limit(5).forEach(System.out::println);
		//you can also use custom supplier in generate() method
		IntStream.generate(_003_Functions::fn2)
		.limit(5).forEach(System.out::println);

		//IntStream iterate(int seed, IntUnaryOperator f) returns an infinite sequential ordered IntStream produced by iterative applying f to seed.
		//It produces a Stream consisting of seed, f(seed), f(f(seed)), etc.
		IntStream.iterate(3, n->n+2).limit(5).forEach(System.out::println);

		//IntStream range(int startInclusive, int endExclusive) returns a sequential ordered IntStream from startInclusive (inclusive) to endExclusive (exclusive) by an incremental step of 1.
		s1 = IntStream.range(66,70);
		s1.forEach(System.out::println);	

		//IntStream rangeClosed(int startInclusive, int endInclusive) returns an IntStream from startInclusive (inclusive) to endInclusive (inclusive) by an incremental step of 1.
		s1 = IntStream.rangeClosed(66,70);
		s1.forEach(System.out::println);

		System.out.println("====================INTERMEDIATE OPERATION====================");
		//IntStream empty() returns an empty sequential IntStream.
		IntStream i1=IntStream.empty();
		System.out.println(i1.count());
		
		//IntStream concat(IntStream a, IntStream b) concatenates streams.
		IntStream a = IntStream.concat(IntStream.of(1,2,3), IntStream.of(6,7,8));
		a.forEach(System.out::println);
		
		//IntStream asLongStream() returns a LongStream consisting of the elements of this stream, converted to long. 
		s1 = IntStream.of(1,2,3,4,5);
		s1.asLongStream().forEach(System.out::println);

		//IntStream asDoubleStream() returns a DoubleStream consisting of the elements of this stream, converted to double. 
		s1 = IntStream.of(1,2,3,4,5);
		s1.asDoubleStream().forEach(System.out::println);

		//IntStream boxed() returns a Stream boxed to an Integer. 
		s1 = IntStream.of(1,2,3,4,5);
		s1.boxed().forEach(System.out::println);		

		//IntStream map(IntUnaryOperator mapper) returns a stream by applying the given function.
		s1 = IntStream.of(1,2,3,4,5);
		s1.map(n->-n).forEach(System.out::println);

		//IntStream flatMap(IntFunction<? extends IntStream> mapper) returns a stream by a mapped stream using mapping function.
		IntStream s3 = IntStream.of(1,2,3,4,5);
		IntStream s4 = s3.flatMap(n->IntStream.of(n*n));
		s4.forEach(System.out::println);

		//IntStream mapToDouble(IntToDoubleFunction mapper) returns a DoubleStream consisting of the results of applying the given function.
		s1 = IntStream.of(1,2,3,4,5);
		DoubleStream mTD = s1.mapToDouble(n->Math.sin(n));
		mTD.forEach(System.out::println);

		//IntStream mapToLong(IntToLongFunction mapper) returns a LongStream consisting of the results of applying the given function.
		s1 = IntStream.of(1,2,3,4,5);
		LongStream mTL = s1.mapToLong(n->(long)n);
		mTL.forEach(System.out::println);

		//IntStream mapToObj(IntFunction<? extends U> mapper) returns an object-valued Stream consisting of the results of applying the given function.
		s1 = IntStream.of(1,2,3,4,5);
		Stream<String> mTO = s1.mapToObj(n->Integer.toBinaryString(n));
		mTO.forEach(System.out::println);		

		//IntStream filter(IntPredicate predicate) returns a stream that match the given predicate.
		s1 = IntStream.of(1,2,3,4,5);
		s1.filter(n->n%2==0)
		.forEach(System.out::println);
		
		//IntStream distinct() returns a stream consisting of the distinct elements of this stream. 
		s1=IntStream.of(1,2,3,1,2,3);
		s1.distinct().forEach(System.out::println);

		//IntStream limit(long maxSize) returns a stream consisting of the elements of this stream, truncated to be no longer than maxSize in length.
		s1 = IntStream.of(1,2,3,4,5);
		s1.limit(2).forEach(System.out::println);		

		//IntStream skip(long n) returns a stream by discarding the first n elements of the stream.
		s1 = IntStream.iterate(1, n->n+1);
		s1.skip(10000).limit(5).forEach(System.out::println);

		//IntStream parallel() returns a parallel IntStream.
		s1 = IntStream.of(5,4,3,2,1);
		s1.parallel().forEach(System.out::println);

		System.out.println("===========PEEK===========");
		//IntStream peek(IntConsumer action) returns a stream consisting of the elements of this stream, performing the provided action.
		//We can debug a stream by using the peek(Consumer<? super T> action) method of the Stream<T> interface. We can use a lambda expression 
		//with the peek() method to log elements.
		s1 = IntStream.of(1,2,3,4,5);
		s1.peek(System.out::println) //takes consumer and return the stream
		.forEach(System.out::println);
		
		System.out.println(
		Employee.create().stream()
		.peek(System.out::println)
		.filter(Employee::isMale)
		.peek(e->System.out.println(e.getName()))
		.filter(e->e.getIncome()>2000)
		.collect(Collectors.toList()));
		
		//DoubleStream collect(Supplier<R> supplier, ObjDoubleConsumer<R> accumulator, BiConsumer<R,R> combiner) performs a mutable reduction 
		//operation on the elements of this stream.
		s1 = IntStream.of(1,2,3,4,5);
		List<Integer> listInt = s1.collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
		System.out.println(listInt);
		
		//IntStream sequential() returns a sequential IntStream
		s1 = IntStream.of(1,2,3,4,5);
		s1.sequential().forEach(System.out::println);

		//IntStream sorted() returns a stream consisting of the elements of this stream in sorted order. 
		s1 = IntStream.of(3,2,4,1,5);
		s1.sorted().forEach(System.out::println);			

		//IntStream iterator() returns the PrimitiveIterator.
		s1 = IntStream.of(1,2,3,4,5);
		PrimitiveIterator.OfInt x = s1.iterator();
		while(x.hasNext()) System.out.println(x.nextInt());

		//IntStream spliterator() returns the Spliterator for IntStream.
		s1 = IntStream.of(1,2,3,4,5);
		Spliterator.OfInt x2 = s1.spliterator();
		System.out.println(x2.characteristics());
		
		System.out.println("==========================================================");
		System.out.println("====================TERMINAL OPERATION====================");
		System.out.println("==========================================================");
		//IntStream forEach(IntConsumer action) performs an action for each element of this stream. 
		s1 = IntStream.of(1,2,3,4,5);
		s1.forEach(System.out::println);

		//IntStream forEachOrdered(IntConsumer action) performs an action for each element of this stream in encounter order. 
		s1 = IntStream.of(1,2,3,4,5);
		s1.forEachOrdered(System.out::println);

		//IntStream sum() returns the sum of elements in this stream.
		s1 = IntStream.of(1,2,3,4,5);
		System.out.println(s1.sum());

		//IntStream average() returns an OptionalDouble describing the arithmetic mean of elements of this stream, or an empty optional if this stream is empty.
		s1 = IntStream.of(1,2,3,4,5);
		System.out.println(s1.average());		
		//Since average() returns OptionalDouble, we need to do below
		s1 = IntStream.of(1,2,3,4,5);
		OptionalDouble d = s1.average();
		if (d.isPresent()) System.out.println(d.getAsDouble());
		else System.out.println("no value");
		
		//IntStream max() returns an OptionalInt describing the maximum element of this stream, or an empty optional if this stream is empty.
		s1 = IntStream.of(1,2,3,4,5);
		OptionalInt max = s1.max();
		if(max.isPresent()) System.out.println(max.getAsInt()); else System.out.println("no value");

		//IntStream min() returns an OptionalInt describing the minimum element of this stream, or an empty optional if this stream is empty.
		s1 = IntStream.of(1,2,3,4,5);
		OptionalInt min = s1.min();
		if(min.isPresent()) System.out.println(min.getAsInt()); else System.out.println("no value");
		
		//IntStream count() returns the count of elements in this stream.
		System.out.println(Employee.create().stream().count());
		System.out.println(Employee.create().stream().mapToInt(e->1).sum()); //without using count()
		System.out.println(Employee.create().stream().map(e->1).reduce(0,Integer::sum));
		System.out.println(Employee.create().stream().map(e->1).reduce(0,(partialCount,nextElement)->Integer.sum(partialCount,nextElement)));
		System.out.println(Employee.create().stream().reduce(0,(partialCount, e)->Integer.sum(partialCount,1), Integer::sum));

		//IntStream summaryStatistics() returns an IntSummaryStatistics describing various summary data about the elements of this stream.
		s1 = IntStream.of(1,2,3,4,5);
		IntSummaryStatistics stats=s1.summaryStatistics();
		System.out.println(stats);
		System.out.println(stats.getAverage());
		System.out.println(stats.getCount());
		System.out.println(stats.getMax());
		System.out.println(stats.getMin());
		System.out.println(stats.getSum());
		
		System.out.println("STREAM MATCH OPERATIONS...........");
		//IntStream allMatch(IntPredicate predicate) returns whether all elements of this stream match the provided predicate.
		s1 = IntStream.of(1,2,3,4,5);
		System.out.println(s1.allMatch(n->n>0));
		
		System.out.println(Employee.create().stream().allMatch(Employee::isMale));
		System.out.println(Employee.create().stream().allMatch(e->e.getIncome()>1000));

		//IntStream noneMatch(IntPredicate predicate) returns whether no elements of this stream match the provided predicate.
		s1 = IntStream.of(1,2,3,4,5);
		System.out.println(s1.noneMatch(n->n>0));
		
		System.out.println(Employee.create().stream().noneMatch(Employee::isMale));
		System.out.println(Employee.create().stream().noneMatch(e->e.getIncome()>1000));
		
		//IntStream anyMatch(IntPredicate predicate) returns whether any elements of this stream match the provided predicate.
		s1 = IntStream.of(1,2,3,4,5);
		System.out.println(s1.anyMatch(n->n>5));
		
		System.out.println(Employee.create().stream().anyMatch(Employee::isMale));
		System.out.println(Employee.create().stream().anyMatch(e->e.getIncome()>1000));		
		
		System.out.println("STREAM FIND OPERATIONS.............");
		//IntStream findAny() returns an OptionalInt describing some element of the stream, or an empty OptionalInt if the stream is empty.
		s1 = IntStream.of(1,2,3,4,5);
		OptionalInt oi = s1.filter(n->n%5==0).findAny();
		if (oi.isPresent()) System.out.println(oi.getAsInt());
		else System.out.println("no number is divisible by 5");
		
		System.out.println(Employee.create().stream().filter(Employee::isMale).findAny());
		System.out.println(Employee.create().stream().filter(e->e.getIncome()>1000).findAny());

		//IntStream findFirst() returns an OptionalInt describing the first element of this stream, or an empty OptionalInt if the stream is empty.
		s1 = IntStream.of(1,2,3,4,5);
		OptionalInt oi2=s1.findFirst();
		if (oi2.isPresent()) System.out.println(oi2.getAsInt());
		else System.out.println("no value");
		
		System.out.println(Employee.create().stream().filter(Employee::isMale).findFirst());
		System.out.println(Employee.create().stream().filter(e->e.getIncome()>1000).findFirst());
		
		System.out.println("====================ARRAY==================");
		//IntStream toArray() returns an array containing the elements of this stream. 
		s1 = IntStream.of(1,2,3,4,5);
		int[] intArray = s1.toArray();
		for (int i: intArray) System.out.print(i +" ");
		
		System.out.println("STREAM REDUCE OPERATIONS.............");
		//IntStream reduce(IntBinaryOperator op) performs a reduction on the elements of this stream, using an associative accumulation function, 
		//and returns an OptionalInt describing the reduced value, if any.
		s1 = IntStream.of(1,2,3,4,5);
		System.out.println(s1.reduce((partialCount,nextElement)->partialCount+nextElement));

		//IntStream reduce(int identity, IntBinaryOperator op) pPerforms a reduction on the elements of this stream, using the provided identity 
		//value and an associative accumulation function, and returns the reduced value.
		s1 = IntStream.of(1,2,3,4,5);
		System.out.println(s1.reduce(0, (partialCount,nextElement)->partialCount+nextElement));
		
	}
}





