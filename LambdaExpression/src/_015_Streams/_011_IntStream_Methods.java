/*
java.util.stream Package 

Stream
Stream.Builder
IntStream
IntStream.Builder
LongStream
LongStream.Builder
DoubleStream
DoubleStream.Builder

Here I am showing method usage for IntStream and IntStream.Builder
Same methods are available for other as well.
 */

package _015_Streams;

import java.util.IntSummaryStatistics;
import java.util.OptionalDouble;
import java.util.OptionalInt;
import java.util.PrimitiveIterator;
import java.util.Spliterator;
import java.util.function.IntSupplier;
import java.util.stream.Collectors;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;

import _099_helper.Functions;

public class _011_IntStream_Methods {
	public static void main(String[] args){
		IntStream s1 = IntStream.of(1,2,3,4,5);

		System.out.println("=====================================================");
		System.out.println("====================CREATE STREAM====================");
		System.out.println("=====================================================");
		//IntStream of(int t) returns a sequential IntStream containing a single element.
		IntStream s2 = IntStream.of(99);
		s2.forEach(System.out::println);

		//IntStream of(int... values) returns a sequential ordered stream whose elements are the specified values.
		IntStream s5 = IntStream.of(1,2,3,4,5);
		s5.forEach(System.out::println);

		//IntStream builder() returns a builder for an IntStream. build() returns the IntStream.
		s1 = IntStream.builder() 
				.add(1) //add() returns builder
				.add(2)
				.add(3)
				.add(4) 
				.build();
		s1.forEach(System.out::println);
		
		IntStream.Builder builder = IntStream.builder();
		builder.accept(1); //accept() returns nothing
		builder.accept(2);
		builder.accept(3);
		builder.accept(4);
		IntStream intStream = builder.build();
		intStream.forEach(System.out::println);

		/*
		We can have a function that can generate values on demand.

		The following two static methods from Stream interface generates an infinite stream from a function.

		<T> Stream<T> iterate(T  seed, UnaryOperator<T>  f)
		<T> Stream<T> generate(Supplier<T> s)

		Stream.iterate()
		iterate() method creates a sequential ordered stream.
		The iterate() method takes two arguments: a seed and a function.
		A seed is the first element of the stream. The second element is generated by applying the function to the first element. The third element is generated 
		by applying the function on the second element.
		Therefore the elements are: seed, f(seed), f(f(seed)), f(f(f(seed)))....

		Stream.generate()
		generate() method creates a sequential unordered stream.
		generate(Supplier<T> s) uses Supplier to generate an infinite sequential unordered stream.

		IntStream, LongStream, and DoubleStream contain iterate() and generate() methods that take parameters specific to their primitive types and generate values.
		For example, the following two methods are defined in the IntStream interface:

		IntStream iterate(int seed,  IntUnaryOperator f)
		IntStream generate(IntSupplier s)

		 */
		
		/*
		  generate() method generates an infinite stream of elements by repeatedly invoking the overridden method of same instance of provided 
		  IntSupplier So if your method works with local variable, the value will get reset (and will not have updated value). So this will not 
		  work. To make it work, create instance variable.
		  
		  Math.random() produce a random number with every invocation.
		 */
		IntStream.generate(()->(int)Math.random())
		.limit(5).forEach(System.out::println);
		
		DoubleStream.generate(Math::random)
		.limit(5).forEach(System.out::println);		

		IntStream.generate(new IntSupplier() {			
			@Override
			public int getAsInt() { 
				int j=44; //THIS DOES NOT WORK
				j=j+1;
				return j;
			}
		})
		.limit(5).forEach(System.out::println);
		
		IntStream.generate(new IntSupplier() {			
			int j=44; //THIS WORKS			
			@Override
			public int getAsInt() {
				j=j+1;
				return j;
			}
		})
		.limit(5).forEach(System.out::println);
		
		//how to generate fibonnaci series
		IntStream.generate(new IntSupplier(){
			int previousValue = 100000;
			int currentValue = 100001;

			@Override
			public int getAsInt() {
				int nextValue = currentValue + previousValue;
				this.previousValue=currentValue;
				this.currentValue=nextValue;
				return previousValue;
			}
		})
		.limit(5).forEach(System.out::println);		
		
		IntStream.generate(Functions::fn1) //THIS DOES NOT WORK since we are using local variable
		.limit(5).forEach(System.out::println);
		
		IntStream.generate(Functions::fn2) //THIS WORKS since we are using instance variable
		.limit(5).forEach(System.out::println);

		IntStream.iterate(3, n->n+2)
		.limit(5).forEach(System.out::println);
		
		//IntStream range(int startInclusive, int endExclusive) returns a sequential ordered IntStream from startInclusive (inclusive) to 
		//endExclusive(exclusive) by an incremental step of 1.
		s1 = IntStream.range(66,70);
		s1.forEach(System.out::println);	

		//IntStream rangeClosed(int startInclusive, int endInclusive) returns an IntStream from startInclusive (inclusive) to endInclusive 
		//(inclusive) by an incremental step of 1.
		s1 = IntStream.rangeClosed(66,70);
		s1.forEach(System.out::println);

		//IntStream empty() returns an empty sequential IntStream.
		IntStream i1=IntStream.empty();
		System.out.println(i1.count());
		
		System.out.println("==============================================================");
		System.out.println("====================INTERMEDIATE OPERATION====================");		
		System.out.println("==============================================================");
		/*IntStream parallel() returns a parallel IntStream.
		print order can be anything due to parallel streams.
		*/
		s1 = IntStream.of(5,4,3,2,1);
		s1.parallel().forEach(System.out::println);
		
		//IntStream concat(IntStream a, IntStream b) concatenates streams.
		IntStream a = IntStream.concat(IntStream.of(1,2,3), IntStream.of(6,7,8));
		a.forEach(System.out::println);
		
		//IntStream asLongStream() returns a LongStream consisting of the elements of this stream, converted to long. 
		s1 = IntStream.of(1,2,3,4,5);
		s1.asLongStream().forEach(System.out::println);

		//IntStream asDoubleStream() returns a DoubleStream consisting of the elements of this stream, converted to double. 
		s1 = IntStream.of(1,2,3,4,5);
		s1.asDoubleStream().forEach(System.out::println);

		//IntStream boxed() returns a Stream boxed to an Integer. 
		s1 = IntStream.of(1,2,3,4,5);
		s1.boxed().forEach(System.out::println);		
		
		IntStream.iterate(3, n->n+2).limit(5).boxed()
		.collect(Collectors.toList()); //collections don't accept primitives, so you need to box it first.

		/*
		 A map operation applies a function to each element to produce another stream.
		 The number of elements in the input and output streams is the same.
		 */
		//IntStream map(IntUnaryOperator mapper) returns a stream by applying the given function.
		s1 = IntStream.of(1,2,3,4,5);
		s1.map(n->-n).forEach(System.out::println);

		//IntStream flatMap(IntFunction<? extends IntStream> mapper) returns a stream by a mapped stream using mapping function.
		IntStream s3 = IntStream.of(1,2,3,4,5);
		//I am creating a stream for every input from upstream, and then flattening all of them to a single stream.
		IntStream s4 = s3.flatMap(n->IntStream.of(n*n)); 
		s4.forEach(System.out::println);

		//IntStream mapToDouble(IntToDoubleFunction mapper) returns a DoubleStream consisting of the results of applying the given function.
		s1 = IntStream.of(1,2,3,4,5);
		DoubleStream mTD = s1.mapToDouble(n->Math.sin(n));
		mTD.forEach(System.out::println);

		//IntStream mapToLong(IntToLongFunction mapper) returns a LongStream consisting of the results of applying the given function.
		s1 = IntStream.of(1,2,3,4,5);
		LongStream mTL = s1.mapToLong(n->(long)n);
		mTL.forEach(System.out::println);

		//IntStream mapToObj(IntFunction<? extends U> mapper) returns an object-valued Stream consisting of the results of applying the given 
		//function.
		s1 = IntStream.of(1,2,3,4,5);
		Stream<String> mTO = s1.mapToObj(n->Integer.toBinaryString(n));
		mTO.forEach(System.out::println);		

		/*
		The filter operation produces a filtered stream, a subset of the input stream, whose elements evaluate to true for the specified predicate.
		The filtered stream has the same type as the input stream.
		If the predicate evaluates to false for all elements, it produces an empty stream.
		 */
		//IntStream filter(IntPredicate predicate) returns a stream that match the given predicate.
		s1 = IntStream.of(1,2,3,4,5);
		s1.filter(n->n%2==0)
		.forEach(System.out::println);

		//IntStream limit(long maxSize) returns a stream consisting of the elements of this stream, truncated to be no longer than maxSize in length.
		s1 = IntStream.of(1,2,3,4,5);
		s1.limit(2).forEach(System.out::println);		

		//IntStream skip(long n) returns a stream by discarding the first n elements of the stream.
		s1 = IntStream.iterate(1, n->n+1);
		s1.skip(10000).limit(5).forEach(System.out::println);
		
		//IntStream distinct() returns a stream consisting of the distinct elements of this stream. 
		s1=IntStream.of(1,2,3,1,2,3);
		s1.distinct().forEach(System.out::println);
		
		//IntStream peek(IntConsumer action) returns a stream consisting of the elements of this stream, performing the provided action.
		//We can debug a stream by using the peek(Consumer<? super T> action) method of the Stream<T> interface. We can use a lambda expression 
		//with the peek() method to log elements.
		s1 = IntStream.of(1,2,3,4,5);
		s1.peek(System.out::println) //consume stream elements, and pass on the stream to downside operation 
		.forEach(System.out::println);

		//IntStream sorted() returns a stream consisting of the elements of this stream in sorted order. 
		s1 = IntStream.of(3,2,4,1,5);
		s1.sorted().forEach(System.out::println);	
		
		//IntStream sequential() returns a sequential IntStream
		s1 = IntStream.of(1,2,3,4,5);
		s1.sequential().forEach(System.out::println);

		//IntStream iterator() returns the PrimitiveIterator.
		s1 = IntStream.of(1,2,3,4,5);
		PrimitiveIterator.OfInt x = s1.iterator();
		while(x.hasNext()) System.out.println(x.nextInt());

		//IntStream spliterator() returns the Spliterator for IntStream.
		s1 = IntStream.of(1,2,3,4,5);
		Spliterator.OfInt x2 = s1.spliterator();
		System.out.println(x2.characteristics());
		
		System.out.println("==========================================================");
		System.out.println("====================TERMINAL OPERATION====================");
		System.out.println("==========================================================");
		//IntStream forEach(IntConsumer action) performs an action for each element of this stream. 
		s1 = IntStream.of(1,2,3,4,5);
		s1.forEach(System.out::println);

		//IntStream forEachOrdered(IntConsumer action) performs an action for each element of this stream in encounter order. 
		s1 = IntStream.of(1,2,3,4,5);
		s1.forEachOrdered(System.out::println);
		
		/*forEach() vs forEachOrdered()
		 
		 The second line will always output: 1 2 3 4 5. whereas the first one is not guaranteed since the order is not kept. forEachOrdered will 
		 processes the elements of the stream in the order specified by its source, regardless of whether the stream is sequential or parallel.
		 
		 forEach():The behavior of this operation is explicitly nondeterministic. For parallel stream pipelines, this operation does not guarantee 
		 to respect the encounter order of the stream, as doing so would sacrifice the benefit of parallelism.
		 
		 forEachOrdered(): Performs an action for each element of this stream, in the encounter order of the stream if the stream has a defined 
		 encounter order.
		 */
		IntStream.of(1,2,3,4,5).parallel().forEach(System.out::println);
		IntStream.of(1,2,3,4,5).parallel().forEachOrdered(System.out::println);

		System.out.println("================AGGREGATE OPERATIONS================");
		//IntStream sum() returns the sum of elements in this stream.
		s1 = IntStream.of(1,2,3,4,5);
		System.out.println(s1.sum());
		
		//IntStream max() returns an OptionalInt describing the maximum element of this stream, or an empty optional if this stream is empty.
		s1 = IntStream.of(1,2,3,4,5);
		OptionalInt max = s1.max();
		if(max.isPresent()) System.out.println(max.getAsInt()); else System.out.println("no value");

		//IntStream min() returns an OptionalInt describing the minimum element of this stream, or an empty optional if this stream is empty.
		s1 = IntStream.of(1,2,3,4,5);
		OptionalInt min = s1.min();
		if(min.isPresent()) System.out.println(min.getAsInt()); else System.out.println("no value");
		
		//IntStream average() returns an OptionalDouble describing the arithmetic mean of elements of this stream, or an empty optional if this 
		//stream is empty.
		s1 = IntStream.of(1,2,3,4,5);
		System.out.println(s1.average());		
		//Since average() returns OptionalDouble, we need to do below
		s1 = IntStream.of(1,2,3,4,5);
		OptionalDouble d = s1.average();
		if (d.isPresent()) System.out.println(d.getAsDouble());
		else System.out.println("no value");
		
		/*
		 Streams support a count operation through the count() method that returns the number of elements in the stream as a long.
		 */
		//IntStream count() returns the count of elements in this stream.
		s1 = IntStream.of(1,2,3,4,5);
		System.out.println(s1.count());

		/*
		The java.util package contains three classes to collect statistics:
		DoubleSummaryStatistics
		LongSummaryStatistics
		IntSummaryStatistics
		We can use them to compute the summary statistics on any group of numeric data.
		 */
		//IntStream summaryStatistics() returns an IntSummaryStatistics describing various summary data about the elements of this stream.
		s1 = IntStream.of(1,2,3,4,5);
		IntSummaryStatistics stats=s1.summaryStatistics();
		System.out.println(stats);
		System.out.println(stats.getAverage());
		System.out.println(stats.getCount());
		System.out.println(stats.getMax());
		System.out.println(stats.getMin());
		System.out.println(stats.getSum());
		
		System.out.println("================MATCH OPERATIONS================");
		//IntStream allMatch(IntPredicate predicate) returns whether all elements of this stream match the provided predicate.
		s1 = IntStream.of(1,2,3,4,5);
		System.out.println(s1.allMatch(n->n>0));

		//IntStream noneMatch(IntPredicate predicate) returns whether no elements of this stream match the provided predicate.
		s1 = IntStream.of(1,2,3,4,5);
		System.out.println(s1.noneMatch(n->n>0));
		
		//IntStream anyMatch(IntPredicate predicate) returns whether any elements of this stream match the provided predicate.
		s1 = IntStream.of(1,2,3,4,5);
		System.out.println(s1.anyMatch(n->n>3));
		
		System.out.println("=================FIND OPERATIONS==================");
		//IntStream findAny() returns an OptionalInt describing some element of the stream, or an empty OptionalInt if the stream is empty.
		s1 = IntStream.of(1,2,3,4,5);
		OptionalInt oi = s1.filter(n->n%5==0).findAny();
		if (oi.isPresent()) System.out.println(oi.getAsInt());
		else System.out.println("no number is divisible by 5");

		//IntStream findFirst() returns an OptionalInt describing the first element of this stream, or an empty OptionalInt if the stream is empty.
		s1 = IntStream.of(1,2,3,4,5);
		OptionalInt oi2=s1.findFirst();
		if (oi2.isPresent()) System.out.println(oi2.getAsInt());
		else System.out.println("no value");
		
		/*findAny() vs findFirst()
		The behavior of findAny() is explicitly nondeterministic; it is free to select any element in the stream. This is to allow for 
		maximal performance in parallel operations; the cost is that multiple invocations on the same source may not return the same result. 
		If a stable result is desired, use findFirst() instead. So to put it more simply, findAny() may or may not choose the first element 
		of the Stream. It will return the first element in non-parallel pipeline. However, in a parallel pipeline, it won't always.
		*/
		System.out.println(IntStream.of(1,2,3,4,5).findAny()); //behave just like findFirst()
		System.out.println(IntStream.of(1,2,3,4,5).parallel().findAny());
		System.out.println(IntStream.of(1,2,3,4,5).parallel().findFirst());
		
		System.out.println("====================ARRAY==================");
		//IntStream toArray() returns an array containing the elements of this stream. 
		s1 = IntStream.of(1,2,3,4,5);
		int[] intArray = s1.toArray();
		for (int i: intArray) System.out.print(i +" ");
		
		System.out.println("==================REDUCE==================");
		//check another class specific to reduce()
		
		System.out.println("==================COLLECT==================");
		//check another class specific to collect()
	}
}

